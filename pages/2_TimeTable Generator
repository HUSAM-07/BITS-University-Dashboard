import streamlit as st
import pandas as pd
import numpy as np
import fitz  # PyMuPDF
from tabula import read_pdf
from constraint import Problem
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
from streamlit_js_eval import streamlit_js_eval

# Helper functions

def remove_header(df):
    header_row_index = df[df.iloc[:, 0] == 'COM COD'].index[0]
    df = df.drop(index=df.index[:header_row_index]).reset_index(drop=True)
    df.columns = df.iloc[0]
    df = df.drop(index=0).reset_index(drop=True)
    return df

def forward_fill_course_details(df):
    df['COURSE TITLE'].fillna(method='ffill', inplace=True)
    df['COURSE NO.'].fillna(method='ffill', inplace=True)
    df['CREDIT\rL P U'].fillna(method='ffill', inplace=True)
    return df

def map_days_hours_to_time_slots(day_hour_str):
    days = {'M': 'Monday', 'T': 'Tuesday', 'W': 'Wednesday', 'Th': 'Thursday', 'F': 'Friday', 'S': 'Saturday', 'Su': 'Sunday'}
    day_hour_list = []
    day_str = ''
    hour_str = ''
    for char in day_hour_str:
        if char.isalpha():
            if day_str and hour_str:
                day = days.get(day_str, "Unknown Day")
                for hour in hour_str:
                    slot = time_slots[day][int(hour)-1]
                    day_hour_list.append((day, slot))
                day_str = ''
                hour_str = ''
            day_str += char
        elif char.isdigit():
            hour_str += char
    if day_str and hour_str:
        day = days.get(day_str, "Unknown Day")
        for hour in hour_str:
            slot = time_slots[day][int(hour)-1]
            day_hour_list.append((day, slot))
    return day_hour_list

def clean_course_title(title):
    words = title.split()
    if 'Practical' in words:
        while words.count('Practical') > 1:
            words.remove('Practical')
        return ' '.join(words)
    else:
        return title

def no_overlap(section1, section2):
    times1 = section1[1]  
    times2 = section2[1]
    for day1, time_range1 in times1:
        for day2, time_range2 in times2:
            if day1 == day2:
                start1, end1 = [int(t.replace(':', '')) for t in time_range1.split('-')]
                start2, end2 = [int(t.replace(':', '')) for t in time_range2.split('-')]
                if not (end1 <= start2 or start1 >= end2):
                    return False
    return True

def all_courses_no_overlap(*sections):
    for i in range(len(sections)):
        for j in range(i + 1, len(sections)):
            if not no_overlap(sections[i], sections[j]):
                return False
    return True

def highlight_practicals(df):
    styles_df = pd.DataFrame("", index=df.index, columns=df.columns)
    
    def apply_styles(cell, col_name, row_index):
        style = "background-color: lightgrey; color: black;"
        if "Practical" in str(cell) or "LABORATORY" in str(cell):
            style = "background-color: lightyellow; color: black;"
        if col_name == "Friday" and row_index >= 6:
            style = "background-color: black; color: white;"
        return style

    for col_name in df.columns:
        for row_index, cell in enumerate(df[col_name], start=1):
            styles_df.at[row_index, col_name] = apply_styles(cell, col_name, row_index)

    table_styles = [{'selector': 'th, td', 'props': [('border', '1px solid black')]}]
    return df.style.apply(lambda x: styles_df[x.name], axis=0).set_table_styles(table_styles)

def generate_csv(df):
    return df.to_csv(index=False).encode()

def generate_timetable(uploaded_file):
    doc = fitz.open(stream=uploaded_file.read(), filetype='pdf')
    num_pages = len(doc)
    doc.close()

    tables = read_pdf(uploaded_file, pages='all', multiple_tables=True)
    if tables:
        df = remove_header(tables[0])
        column_names = df.columns
        for i in range(1, num_pages):
            temp_df = tables[i]
            temp_df.columns = column_names
            df = pd.concat([df, temp_df], ignore_index=True)
        
        df = df.drop('COM COD', axis=1)
        df = forward_fill_course_details(df)
        df = df.dropna(subset=['DAYS/  HOURS'])
        df['TIME SLOTS'] = df['DAYS/  HOURS'].apply(map_days_hours_to_time_slots)
        
        return df
    return None

# Main Streamlit app

st.set_page_config(page_title="Timetable Generator", layout="wide")
st.title("Timetable Generator")

# Initialize session state
if 'year' not in st.session_state:
    st.session_state.year = None
if 'semester' not in st.session_state:
    st.session_state.semester = None
if 'discipline' not in st.session_state:
    st.session_state.discipline = None
if 'constraints' not in st.session_state:
    st.session_state.constraints = {}
if 'electives' not in st.session_state:
    st.session_state.electives = {}
if 'timetable_df' not in st.session_state:
    st.session_state.timetable_df = None

# User inputs
year_options = ["First Year", "Second Year", "Third Year", "Fourth Year"]
semester_options = ["First Semester", "Second Semester"]
discipline_options = ["Computer Science (CS)", "Electrical Engineering (EEE)",
                      "Electronics and Communication (ECE)", "Chemical Engineering (Chem)",
                      "Civil Engineering (Civil)"]

with st.form("academic_info_form"):
    st.subheader("Enter Academic Information")
    year = st.radio("Select Year", options=year_options, horizontal=True)
    semester = st.radio("Select Semester", options=semester_options, horizontal=True)
    discipline = st.selectbox("Select Discipline", options=discipline_options)
    uploaded_file = st.file_uploader("Upload the academic calendar (PDF)", type="pdf")
    submitted = st.form_submit_button("Generate Timetable")

if submitted and uploaded_file:
    st.session_state.year = year
    st.session_state.semester = semester
    st.session_state.discipline = discipline
    
    df = generate_timetable(uploaded_file)
    if df is not None:
        st.session_state.timetable_df = df
        st.success("Timetable generated successfully!")
    else:
        st.error("Failed to generate timetable. Please check your PDF file.")

# Display timetable
if st.session_state.timetable_df is not None:
    st.subheader("Your Timetable")
    st.dataframe(highlight_practicals(st.session_state.timetable_df))
    
    # Download button
    csv = generate_csv(st.session_state.timetable_df)
    st.download_button(label="Download Timetable (CSV)", data=csv, file_name="timetable.csv", mime="text/csv")

# Add constraints and electives
if st.session_state.timetable_df is not None:
    st.subheader("Add Constraints and Electives")
    
    # Constraints
    available_courses = st.session_state.timetable_df["COURSE TITLE"].unique()
    selected_course = st.selectbox("Select a course for constraint:", available_courses)
    if selected_course:
        available_sections = st.session_state.timetable_df[st.session_state.timetable_df["COURSE TITLE"] == selected_course]["SEC"].unique()
        selected_section = st.selectbox("Select a section:", available_sections)
        if st.button("Add Constraint"):
            st.session_state.constraints[selected_course] = selected_section
            st.success(f"Added constraint: {selected_course} - Section {selected_section}")
    
    # Electives
    elective_courses = st.session_state.timetable_df[st.session_state.timetable_df["COURSE NO."].str.startswith("HSS")]["COURSE TITLE"].unique()
    selected_elective = st.selectbox("Select an elective:", elective_courses)
    if selected_elective:
        if st.button("Add Elective"):
            st.session_state.electives[selected_elective] = True
            st.success(f"Added elective: {selected_elective}")
    
    # Display current constraints and electives
    if st.session_state.constraints:
        st.subheader("Current Constraints")
        for course, section in st.session_state.constraints.items():
            st.write(f"{course} - Section {section}")
    
    if st.session_state.electives:
        st.subheader("Current Electives")
        for elective in st.session_state.electives:
            st.write(elective)
    
    # Regenerate timetable with constraints and electives
    if st.button("Regenerate Timetable"):
        # Here you would implement the logic to regenerate the timetable
        # based on the constraints and electives
        st.info("Timetable regeneration not implemented in this example")

# Time slots definition
time_slots = {
    'Monday': ['7:30-8:20', '8:25-9:15', '9:20-10:10', '10:15-11:05', '11:10-12:00', '12:05-12:55', '1:00-1:50', '1:55-2:45', '2:50-3:40'],
    'Tuesday': ['7:30-8:20', '8:25-9:15', '9:20-10:10', '10:15-11:05', '11:10-12:00', '12:05-12:55', '1:00-1:50', '1:55-2:45', '2:50-3:40'],
    'Wednesday': ['7:30-8:20', '8:25-9:15', '9:20-10:10', '10:15-11:05', '11:10-12:00', '12:05-12:55', '1:00-1:50', '1:55-2:45', '2:50-3:40'],
    'Thursday': ['7:30-8:20', '8:25-9:15', '9:20-10:10', '10:15-11:05', '11:10-12:00', '12:05-12:55', '1:00-1:50', '1:55-2:45', '2:50-3:40'],
    'Friday': ['7:30-8:20', '8:25-9:15', '9:20-10:10', '10:15-11:05', '11:10-12:00'],
}